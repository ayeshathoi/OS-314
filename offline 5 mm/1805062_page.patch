diff --git a/Makefile b/Makefile
index 39a99d7..bab286b 100644
--- a/Makefile
+++ b/Makefile
@@ -24,6 +24,7 @@ OBJS = \
   $K/sleeplock.o \
   $K/file.o \
   $K/pipe.o \
+  $K/swap.o \
   $K/exec.o \
   $K/sysfile.o \
   $K/kernelvec.o \
@@ -132,6 +133,7 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_pagetest\
 
 fs.img: mkfs/mkfs README $(UPROGS)
 	mkfs/mkfs fs.img README $(UPROGS)
diff --git a/fourth.patch b/fourth.patch
new file mode 100644
index 0000000..aa5f510
--- /dev/null
+++ b/fourth.patch
@@ -0,0 +1,661 @@
+diff --git a/Makefile b/Makefile
+index 39a99d7..bab286b 100644
+--- a/Makefile
++++ b/Makefile
+@@ -24,6 +24,7 @@ OBJS = \
+   $K/sleeplock.o \
+   $K/file.o \
+   $K/pipe.o \
++  $K/swap.o \
+   $K/exec.o \
+   $K/sysfile.o \
+   $K/kernelvec.o \
+@@ -132,6 +133,7 @@ UPROGS=\
+ 	$U/_grind\
+ 	$U/_wc\
+ 	$U/_zombie\
++	$U/_pagetest\
+ 
+ fs.img: mkfs/mkfs README $(UPROGS)
+ 	mkfs/mkfs fs.img README $(UPROGS)
+diff --git a/kernel/defs.h b/kernel/defs.h
+index a3c962b..17817f8 100644
+--- a/kernel/defs.h
++++ b/kernel/defs.h
+@@ -8,6 +8,8 @@ struct spinlock;
+ struct sleeplock;
+ struct stat;
+ struct superblock;
++struct swap;
++struct livepage;
+ 
+ // bio.c
+ void            binit(void);
+@@ -36,6 +38,8 @@ int             filewrite(struct file*, uint64, int n);
+ 
+ // fs.c
+ void            fsinit(int);
++uint            balloc(uint dev);
++void            bfree(int dev, uint b);
+ int             dirlink(struct inode*, char*, uint);
+ struct inode*   dirlookup(struct inode*, char*, uint*);
+ struct inode*   ialloc(uint, short);
+@@ -107,6 +111,13 @@ int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
+ int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
+ void            procdump(void);
+ 
++// swap.c
++void            swapinit(void);
++void            swapfree(struct swap*);
++struct swap*    swapalloc(void);
++void            swapout(struct swap *dst_sp, char *src_pa);
++void            swapin(char *dst_pa, struct swap *src_sp);
++
+ // swtch.S
+ void            swtch(struct context*, struct context*);
+ 
+@@ -173,6 +184,14 @@ uint64          walkaddr(pagetable_t, uint64);
+ int             copyout(pagetable_t, uint64, char *, uint64);
+ int             copyin(pagetable_t, char *, uint64, uint64);
+ int             copyinstr(pagetable_t, char *, uint64, uint64);
++// my defined functions in vm.c
++// int             is_live(pagetable_t, uint64);
++void            livepageinit(void);
++void            add_to_live(pagetable_t, uint64, uint64);
++void            remove_from_live(pagetable_t, uint64);
++struct swap *   my_swap_out(uint64);
++uint64          my_swap_in(struct swap *s);
++uint64          actual_swap_in(pte_t* pte);
+ 
+ // plic.c
+ void            plicinit(void);
+diff --git a/kernel/exec.c b/kernel/exec.c
+index e18bbb6..5afb261 100644
+--- a/kernel/exec.c
++++ b/kernel/exec.c
+@@ -80,7 +80,7 @@ exec(char *path, char **argv)
+   // Use the second as the user stack.
+   sz = PGROUNDUP(sz);
+   uint64 sz1;
+-  if((sz1 = uvmalloc(pagetable, sz, sz + 2*PGSIZE, PTE_W)) == 0)
++  if((sz1 = uvmalloc(pagetable, sz, sz + 2*PGSIZE, PTE_W | PTE_G)) == 0)
+     goto bad;
+   sz = sz1;
+   uvmclear(pagetable, sz-2*PGSIZE);
+diff --git a/kernel/fs.c b/kernel/fs.c
+index c6bab15..2d9b419 100644
+--- a/kernel/fs.c
++++ b/kernel/fs.c
+@@ -62,7 +62,7 @@ bzero(int dev, int bno)
+ 
+ // Allocate a zeroed disk block.
+ // returns 0 if out of disk space.
+-static uint
++uint
+ balloc(uint dev)
+ {
+   int b, bi, m;
+@@ -88,7 +88,7 @@ balloc(uint dev)
+ }
+ 
+ // Free a disk block.
+-static void
++void
+ bfree(int dev, uint b)
+ {
+   struct buf *bp;
+diff --git a/kernel/main.c b/kernel/main.c
+index f0d3171..5c36ac0 100644
+--- a/kernel/main.c
++++ b/kernel/main.c
+@@ -19,6 +19,8 @@ main()
+     kinit();         // physical page allocator
+     kvminit();       // create kernel page table
+     kvminithart();   // turn on paging
++    swapinit();
++    livepageinit();
+     procinit();      // process table
+     trapinit();      // trap vectors
+     trapinithart();  // install kernel trap vector
+diff --git a/kernel/proc.c b/kernel/proc.c
+index 959b778..6653574 100644
+--- a/kernel/proc.c
++++ b/kernel/proc.c
+@@ -288,12 +288,13 @@ fork(void)
+     return -1;
+   }
+ 
++  release(&np->lock);
+   // Copy user memory from parent to child.
+   if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){
+     freeproc(np);
+-    release(&np->lock);
+     return -1;
+   }
++  acquire(&np->lock);
+   np->sz = p->sz;
+ 
+   // copy saved user registers.
+@@ -414,9 +415,9 @@ wait(uint64 addr)
+             release(&wait_lock);
+             return -1;
+           }
+-          freeproc(pp);
+           release(&pp->lock);
+           release(&wait_lock);
++          freeproc(pp);
+           return pid;
+         }
+         release(&pp->lock);
+diff --git a/kernel/riscv.h b/kernel/riscv.h
+index 20a01db..ef4e5cc 100644
+--- a/kernel/riscv.h
++++ b/kernel/riscv.h
+@@ -344,6 +344,19 @@ typedef uint64 *pagetable_t; // 512 PTEs
+ #define PTE_X (1L << 3)
+ #define PTE_U (1L << 4) // user can access
+ 
++/* defined for swap out */
++#define PTE_S (1L << 8)
++#define PTE_G (1L << 9)
++#define PTE_SR (1L << 10)
++#define PTE_SW (1L << 11)
++#define PTE_PA (1L << 12)
++
++#define PTE_R_POS 1L
++#define PTE_W_POS 2L
++#define PTE_SR_POS 10L
++#define PTE_SW_POS 11L
++#define PTE_PA_POS 12L
++
+ // shift a physical address to the right place for a PTE.
+ #define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)
+ 
+diff --git a/kernel/swap.c b/kernel/swap.c
+new file mode 100644
+index 0000000..f33bf40
+--- /dev/null
++++ b/kernel/swap.c
+@@ -0,0 +1,135 @@
++#include "types.h"
++#include "riscv.h"
++#include "fs.h"
++#include "spinlock.h"
++#include "defs.h"
++#include "param.h"
++#include "sleeplock.h"
++#include "buf.h"
++
++#define NBLOCKPERPAGE (PGSIZE / BSIZE)
++
++struct swap {
++  uint blocknos[NBLOCKPERPAGE];
++};
++
++struct run {
++  struct run *next;
++};
++
++struct {
++  struct spinlock lock;
++  struct run *freelist;
++} swapmem;
++
++// Initialize swapmem
++void
++swapinit(void)
++{
++  initlock(&swapmem.lock, "swapmem");
++  swapmem.freelist = 0;
++}
++
++// Allocate one swap struct.
++// Returns a pointer to the swap struct.
++// Returns 0 if the memory cannot be allocated.
++struct swap *
++swapalloc(void)
++{
++  struct run *r;
++  struct swap *s;
++
++  acquire(&swapmem.lock);
++  r = swapmem.freelist;
++  if(!r){
++    release(&swapmem.lock);
++    char *mem = kalloc();
++    char *mem_end = mem + PGSIZE;
++    for(; mem + sizeof(struct swap) <= mem_end; mem += sizeof(struct swap)){
++      r = (struct run*)mem;
++
++      acquire(&swapmem.lock);
++      r->next = swapmem.freelist;
++      swapmem.freelist = r;
++      release(&swapmem.lock);
++    }
++    acquire(&swapmem.lock);
++    r = swapmem.freelist;
++  }
++  swapmem.freelist = r->next;
++  release(&swapmem.lock);
++  
++  s = (struct swap*)r;
++  if(s)
++    memset((char*)s->blocknos, 0, sizeof(s->blocknos)); // fill with zeros
++  
++  return s;
++}
++
++// Free the swap struct pointed by s, and the blocks
++// contained in s, which normally should have been returned
++// by a call to swapalloc() and swapout().
++void
++swapfree(struct swap *s)
++{
++  uint *blockno;
++  struct run *r;
++
++  if(!s)
++    panic("swapfree");
++  
++  begin_op();
++  for(blockno = s->blocknos; blockno < &s->blocknos[NBLOCKPERPAGE]; blockno++){
++    if(*blockno)
++      bfree(ROOTDEV, *blockno);
++  }
++  end_op();
++
++  r = (struct run*)s;
++
++  acquire(&swapmem.lock);
++  r->next = swapmem.freelist;
++  swapmem.freelist = r;
++  release(&swapmem.lock);
++}
++
++// Swap out a given physical page src_pa to disk.
++// The metadata for retriving src_pa will be saved
++// to dst_pa which normally should have been returned
++// by a call to swapalloc().
++void
++swapout(struct swap *dst_sp, char *src_pa)
++{
++  uint *blockno;
++  struct buf *bp;
++  
++  begin_op();
++  for(blockno = dst_sp->blocknos; blockno < &dst_sp->blocknos[NBLOCKPERPAGE]; blockno++, src_pa += BSIZE){
++    *blockno = balloc(ROOTDEV);
++    if(*blockno == 0)
++      panic("swapout");
++    bp = bread(ROOTDEV, *blockno);
++    memmove(bp->data, src_pa, BSIZE);
++    log_write(bp);
++    brelse(bp);
++  }
++  end_op();
++}
++
++// Swap in a page into dst_pa from disk using src_sp.
++// src_sp should normally be updated with metadata
++// for retriving the page by a call to swapout().
++void
++swapin(char *dst_pa, struct swap *src_sp)
++{
++  uint *blockno;
++  struct buf *bp;
++  
++  if(!dst_pa)
++    panic("swapin");
++  for(blockno = src_sp->blocknos; blockno < &src_sp->blocknos[NBLOCKPERPAGE]; blockno++, dst_pa += BSIZE){
++    bp = bread(ROOTDEV, *blockno);
++    memmove(dst_pa, bp->data, BSIZE);
++    brelse(bp);
++  }
++}
+diff --git a/kernel/trap.c b/kernel/trap.c
+index 512c850..af15221 100644
+--- a/kernel/trap.c
++++ b/kernel/trap.c
+@@ -50,7 +50,30 @@ usertrap(void)
+   // save user program counter.
+   p->trapframe->epc = r_sepc();
+   
+-  if(r_scause() == 8){
++  /* my code starts */
++  pte_t *pte;
++  uint64 pa, va;
++  // read or write page-fault
++  if(r_scause() == 13 || r_scause() == 15)
++  {
++    va = PGROUNDDOWN(r_stval());
++
++    if(va > p->sz || !va)
++      setkilled(p);
++    else
++    {
++      if((pte = walk(p->pagetable, va, 0)) == 0)
++      panic("usertrap: pte should exist");
++      if((*pte & PTE_S) == 0) // updated condition
++        panic("usertrap: page not present");
++      
++      pa = actual_swap_in(pte);
++      add_to_live(p->pagetable, pa, va);
++    }
++  }
++  /* my code ends */
++  else if(r_scause() == 8)
++  {
+     // system call
+ 
+     if(killed(p))
+@@ -66,6 +89,7 @@ usertrap(void)
+ 
+     syscall();
+   } else if((which_dev = devintr()) != 0){
++    printf("inside usertrap\n");
+     // ok
+   } else {
+     printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
+@@ -145,6 +169,7 @@ kerneltrap()
+     panic("kerneltrap: interrupts enabled");
+ 
+   if((which_dev = devintr()) == 0){
++    printf("inside kerneltrap\n");
+     printf("scause %p\n", scause);
+     printf("sepc=%p stval=%p\n", r_sepc(), r_stval());
+     panic("kerneltrap");
+@@ -189,6 +214,7 @@ devintr()
+     if(irq == UART0_IRQ){
+       uartintr();
+     } else if(irq == VIRTIO0_IRQ){
++      // printf("here\n");
+       virtio_disk_intr();
+     } else if(irq){
+       printf("unexpected interrupt irq=%d\n", irq);
+diff --git a/kernel/vm.c b/kernel/vm.c
+index 9f69783..22b0ab1 100644
+--- a/kernel/vm.c
++++ b/kernel/vm.c
+@@ -15,6 +15,132 @@ extern char etext[];  // kernel.ld sets this to end of kernel code.
+ 
+ extern char trampoline[]; // trampoline.S
+ 
++/* my code starts */
++
++#define MAXPHYPAGES 10
++
++struct livepage {
++  pagetable_t pagetable;
++  uint64 pa, va;
++  int in_use;
++} pages_arr[MAXPHYPAGES];
++
++uint queue_head = 0;
++
++void
++add_to_live(pagetable_t pagetable, uint64 pa, uint64 va)
++{
++  printf("add initial head: %d\n", queue_head);
++  printf("inside add_to_live\n");
++  if(pages_arr[queue_head].in_use)
++  {
++    struct swap *s;
++    pte_t* pte;
++    uint64 flags;
++
++    s = my_swap_out(pages_arr[queue_head].pa);
++    /* update the corresponding pte for this newly swapped out page */
++    if((pte = walk(pages_arr[queue_head].pagetable, pages_arr[queue_head].va, 0)) == 0)
++      panic("add_to_live: pte should exist");
++    if((*pte & PTE_V) == 0)
++      panic("add_to_live: page not present");
++
++    flags = PTE_FLAGS(*pte);
++    *pte = flags | ((flags & PTE_R) << PTE_SR_POS) | ((flags & PTE_W) << PTE_SW_POS) | ((uint64)s << PTE_PA_POS);
++
++    *pte &= ~(PTE_R);
++    *pte &= ~(PTE_W);
++    *pte &= ~(PTE_V);
++    *pte |= PTE_S;
++  }
++
++  pages_arr[queue_head].pagetable = pagetable;
++  pages_arr[queue_head].pa = pa;
++  pages_arr[queue_head].va = va;
++  pages_arr[queue_head].in_use = 1;
++  if(++queue_head == MAXPHYPAGES)
++    queue_head = 0;
++  printf("add final head: %d\n", queue_head);
++}
++
++void
++remove_from_live(pagetable_t pagetable, uint64 va)
++{
++  printf("remove initial head: %d\n", queue_head);
++  printf("inside remove_from_live\n");
++  int i;
++  for(i = 0; i < MAXPHYPAGES; i++)
++    if(pagetable == pages_arr[i].pagetable && va == pages_arr[i].va)
++    {
++      printf("found\n");
++      break;
++    }
++      //break;
++
++  printf("index: %d\n", i);
++
++  for(; i < MAXPHYPAGES-1; i++)
++  {
++    if(pages_arr[i+1].in_use)
++    {
++      pages_arr[i].pagetable = pages_arr[i+1].pagetable;
++      pages_arr[i].pa = pages_arr[i+1].pa;
++      pages_arr[i].va = pages_arr[i+1].va;
++      pages_arr[i].in_use = 1;
++    }
++    else
++    {
++      pages_arr[i].in_use = 0;
++      queue_head = i;
++      break;
++    }
++  }
++  
++  if(i == MAXPHYPAGES-1)
++    queue_head = 0;
++  printf("remove final head: %d\n", queue_head);
++}
++
++struct swap *
++my_swap_out(uint64 pa)
++{
++  struct swap *s = swapalloc();
++  swapout(s, (char*)pa);
++  kfree((void*)pa);
++  return s;
++}
++
++uint64
++my_swap_in(struct swap *s)
++{
++  char* mem = kalloc();
++  swapin(mem, s);
++  swapfree(s);
++  return (uint64)mem;
++}
++
++uint64
++actual_swap_in(pte_t* pte)
++{
++  struct swap *s;
++  uint64 pa;
++  uint flags;
++
++  s = (struct swap*) ((*pte) >> PTE_PA_POS);
++  pa = my_swap_in(s);
++  
++  flags = PTE_FLAGS(*pte);
++  flags |= ((flags & PTE_SR) << PTE_R_POS);
++  flags |= ((flags & PTE_SW) << PTE_W_POS);
++  flags |= PTE_V;
++  flags &= ~(PTE_S); // setting swap flag as 0
++  *pte = flags | (pa << PTE_SR_POS);
++
++  return pa;
++}
++
++/* my code ends */
++
+ // Make a direct-map page table for the kernel.
+ pagetable_t
+ kvmmake(void)
+@@ -56,6 +182,13 @@ kvminit(void)
+   kernel_pagetable = kvmmake();
+ }
+ 
++void
++livepageinit(void)
++{
++  for(int i = 0; i < MAXPHYPAGES; i++)
++    pages_arr[i].in_use = 0;
++}
++
+ // Switch h/w page table register to the kernel's page table,
+ // and enable paging.
+ void
+@@ -170,22 +303,38 @@ mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
+ void
+ uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
+ {
+-  uint64 a;
++  struct swap *s;
++  uint64 a, pa;
+   pte_t *pte;
++  uint flags;
+ 
+   if((va % PGSIZE) != 0)
+     panic("uvmunmap: not aligned");
+ 
+-  for(a = va; a < va + npages*PGSIZE; a += PGSIZE){
++  for(a = va; a < va + npages*PGSIZE; a += PGSIZE)
++  {
+     if((pte = walk(pagetable, a, 0)) == 0)
+       panic("uvmunmap: walk");
+-    if((*pte & PTE_V) == 0)
++    if((*pte & PTE_V) == 0 && (*pte & PTE_S) == 0)
+       panic("uvmunmap: not mapped");
+-    if(PTE_FLAGS(*pte) == PTE_V)
++    if((flags = PTE_FLAGS(*pte)) == PTE_V)
+       panic("uvmunmap: not a leaf");
+-    if(do_free){
+-      uint64 pa = PTE2PA(*pte);
+-      kfree((void*)pa);
++    if(do_free)
++    {
++      if((flags & PTE_U) && !(flags & PTE_X) && !(flags & PTE_G))
++      {
++        if(flags & PTE_S)
++        {
++          s = (struct swap*) ((*pte) >> PTE_PA_POS);
++          swapfree(s);
++        }
++        else
++        {
++          remove_from_live(pagetable, a);
++          pa = PTE2PA(*pte);
++          kfree((void*)pa);
++        }
++      }
+     }
+     *pte = 0;
+   }
+@@ -225,6 +374,7 @@ uvmfirst(pagetable_t pagetable, uchar *src, uint sz)
+ uint64
+ uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm)
+ {
++  printf("inside uvmalloc\n");
+   char *mem;
+   uint64 a;
+ 
+@@ -244,6 +394,11 @@ uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm)
+       uvmdealloc(pagetable, a, oldsz);
+       return 0;
+     }
++
++    // va: a
++    // pa: mem
++    if((xperm & PTE_U) && !(xperm & PTE_X) && !(xperm & PTE_G))
++      add_to_live(pagetable, (uint64)mem, a);
+   }
+   return newsz;
+ }
+@@ -305,18 +460,32 @@ uvmfree(pagetable_t pagetable, uint64 sz)
+ int
+ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
+ {
++  printf("inside uvmcopy\n");
+   pte_t *pte;
+   uint64 pa, i;
+   uint flags;
+   char *mem;
++  // struct swap *s;
+ 
+-  for(i = 0; i < sz; i += PGSIZE){
++  for(i = 0; i < sz; i += PGSIZE)
++  {
+     if((pte = walk(old, i, 0)) == 0)
+       panic("uvmcopy: pte should exist");
+-    if((*pte & PTE_V) == 0)
++    if((*pte & PTE_V) == 0 && (*pte & PTE_S) == 0) // updated condition
+       panic("uvmcopy: page not present");
+-    pa = PTE2PA(*pte);
++
++    /* my code starts */
++    if((*pte) & PTE_S) 
++    {
++      pa = actual_swap_in(pte);
++      if( ((*pte) & PTE_U) && !((*pte) & PTE_X) && !((*pte) & PTE_G) )
++        add_to_live(old, pa, i);
++    }
++    else
++      pa = PTE2PA(*pte);
+     flags = PTE_FLAGS(*pte);
++    /* my code ends */
++
+     if((mem = kalloc()) == 0)
+       goto err;
+     memmove(mem, (char*)pa, PGSIZE);
+@@ -324,6 +493,9 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
+       kfree(mem);
+       goto err;
+     }
++
++    if((flags & PTE_U) && !(flags & PTE_X) && !(flags & PTE_G))
++      add_to_live(new, (uint64)mem, i);
+   }
+   return 0;
+ 
+diff --git a/user/pagetest.c b/user/pagetest.c
+new file mode 100644
+index 0000000..4f4776e
+--- /dev/null
++++ b/user/pagetest.c
+@@ -0,0 +1,17 @@
++#include "kernel/types.h"
++#include "kernel/riscv.h"
++#include "kernel/stat.h"
++#include "user/user.h"
++
++int main(int argc, char *argv[]) {
++    char *mem[15];
++    for (int i = 0; i < 15; ++i) {
++        mem[i] = sbrk(PGSIZE);
++        mem[i][0] = i;
++    }
++    for (int i = 0; i < 15; ++i)
++        printf("%d\n", mem[i][0]);
++    for (int i = 0; i < 15; ++i)
++        free((void *) mem);
++    return 0;
++}
+\ No newline at end of file
diff --git a/kernel/defs.h b/kernel/defs.h
index a3c962b..d6aa7c4 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -8,6 +8,8 @@ struct spinlock;
 struct sleeplock;
 struct stat;
 struct superblock;
+struct swap;
+struct pageList;
 
 // bio.c
 void            binit(void);
@@ -36,6 +38,8 @@ int             filewrite(struct file*, uint64, int n);
 
 // fs.c
 void            fsinit(int);
+uint            balloc(uint dev);
+void            bfree(int dev, uint b);
 int             dirlink(struct inode*, char*, uint);
 struct inode*   dirlookup(struct inode*, char*, uint*);
 struct inode*   ialloc(uint, short);
@@ -107,6 +111,13 @@ int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
 int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
 void            procdump(void);
 
+// swap.c
+void            swapinit(void);
+void            swapfree(struct swap*);
+struct swap*    swapalloc(void);
+void            swapout(struct swap *dst_sp, char *src_pa);
+void            swapin(char *dst_pa, struct swap *src_sp);
+
 // swtch.S
 void            swtch(struct context*, struct context*);
 
@@ -174,6 +185,7 @@ int             copyout(pagetable_t, uint64, char *, uint64);
 int             copyin(pagetable_t, char *, uint64, uint64);
 int             copyinstr(pagetable_t, char *, uint64, uint64);
 
+
 // plic.c
 void            plicinit(void);
 void            plicinithart(void);
@@ -187,3 +199,12 @@ void            virtio_disk_intr(void);
 
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
+
+//---------------------------------------------------------
+void            livepageinit(void);
+void            LivePageAdd(pagetable_t, uint64, uint64);
+void            updatePage(uint,pagetable_t, uint64, uint64);
+void            remove_from_live(pagetable_t, uint64);
+uint64          swap_in_alloc(pte_t* pte);
+void            updateQueueHead(uint);
+//---------------------------------------------------------
\ No newline at end of file
diff --git a/kernel/exec.c b/kernel/exec.c
index e18bbb6..5afb261 100644
--- a/kernel/exec.c
+++ b/kernel/exec.c
@@ -80,7 +80,7 @@ exec(char *path, char **argv)
   // Use the second as the user stack.
   sz = PGROUNDUP(sz);
   uint64 sz1;
-  if((sz1 = uvmalloc(pagetable, sz, sz + 2*PGSIZE, PTE_W)) == 0)
+  if((sz1 = uvmalloc(pagetable, sz, sz + 2*PGSIZE, PTE_W | PTE_G)) == 0)
     goto bad;
   sz = sz1;
   uvmclear(pagetable, sz-2*PGSIZE);
diff --git a/kernel/fs.c b/kernel/fs.c
index c6bab15..2d9b419 100644
--- a/kernel/fs.c
+++ b/kernel/fs.c
@@ -62,7 +62,7 @@ bzero(int dev, int bno)
 
 // Allocate a zeroed disk block.
 // returns 0 if out of disk space.
-static uint
+uint
 balloc(uint dev)
 {
   int b, bi, m;
@@ -88,7 +88,7 @@ balloc(uint dev)
 }
 
 // Free a disk block.
-static void
+void
 bfree(int dev, uint b)
 {
   struct buf *bp;
diff --git a/kernel/riscv.h b/kernel/riscv.h
index 20a01db..dfb04a9 100644
--- a/kernel/riscv.h
+++ b/kernel/riscv.h
@@ -344,6 +344,29 @@ typedef uint64 *pagetable_t; // 512 PTEs
 #define PTE_X (1L << 3)
 #define PTE_U (1L << 4) // user can access
 
+/* defined for swap out */
+//supervisor bit
+#define PTE_S (1L << 8)
+//global bit
+#define PTE_G (1L << 9)
+//supervisor read
+#define PTE_SR (1L << 10)
+//supervisor write
+#define PTE_SW (1L << 11)
+//physical address
+#define PTE_PA (1L << 12)
+
+//read bit
+#define PTE_R_POS 1L
+//write bit
+#define PTE_W_POS 2L
+//supervisor read bit
+#define PTE_SR_POS 10L
+//supervisor write position
+#define PTE_SW_POS 11L
+//physical address bit
+#define PTE_PA_POS 12L
+
 // shift a physical address to the right place for a PTE.
 #define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)
 
diff --git a/kernel/swap.c b/kernel/swap.c
new file mode 100644
index 0000000..f33bf40
--- /dev/null
+++ b/kernel/swap.c
@@ -0,0 +1,135 @@
+#include "types.h"
+#include "riscv.h"
+#include "fs.h"
+#include "spinlock.h"
+#include "defs.h"
+#include "param.h"
+#include "sleeplock.h"
+#include "buf.h"
+
+#define NBLOCKPERPAGE (PGSIZE / BSIZE)
+
+struct swap {
+  uint blocknos[NBLOCKPERPAGE];
+};
+
+struct run {
+  struct run *next;
+};
+
+struct {
+  struct spinlock lock;
+  struct run *freelist;
+} swapmem;
+
+// Initialize swapmem
+void
+swapinit(void)
+{
+  initlock(&swapmem.lock, "swapmem");
+  swapmem.freelist = 0;
+}
+
+// Allocate one swap struct.
+// Returns a pointer to the swap struct.
+// Returns 0 if the memory cannot be allocated.
+struct swap *
+swapalloc(void)
+{
+  struct run *r;
+  struct swap *s;
+
+  acquire(&swapmem.lock);
+  r = swapmem.freelist;
+  if(!r){
+    release(&swapmem.lock);
+    char *mem = kalloc();
+    char *mem_end = mem + PGSIZE;
+    for(; mem + sizeof(struct swap) <= mem_end; mem += sizeof(struct swap)){
+      r = (struct run*)mem;
+
+      acquire(&swapmem.lock);
+      r->next = swapmem.freelist;
+      swapmem.freelist = r;
+      release(&swapmem.lock);
+    }
+    acquire(&swapmem.lock);
+    r = swapmem.freelist;
+  }
+  swapmem.freelist = r->next;
+  release(&swapmem.lock);
+  
+  s = (struct swap*)r;
+  if(s)
+    memset((char*)s->blocknos, 0, sizeof(s->blocknos)); // fill with zeros
+  
+  return s;
+}
+
+// Free the swap struct pointed by s, and the blocks
+// contained in s, which normally should have been returned
+// by a call to swapalloc() and swapout().
+void
+swapfree(struct swap *s)
+{
+  uint *blockno;
+  struct run *r;
+
+  if(!s)
+    panic("swapfree");
+  
+  begin_op();
+  for(blockno = s->blocknos; blockno < &s->blocknos[NBLOCKPERPAGE]; blockno++){
+    if(*blockno)
+      bfree(ROOTDEV, *blockno);
+  }
+  end_op();
+
+  r = (struct run*)s;
+
+  acquire(&swapmem.lock);
+  r->next = swapmem.freelist;
+  swapmem.freelist = r;
+  release(&swapmem.lock);
+}
+
+// Swap out a given physical page src_pa to disk.
+// The metadata for retriving src_pa will be saved
+// to dst_pa which normally should have been returned
+// by a call to swapalloc().
+void
+swapout(struct swap *dst_sp, char *src_pa)
+{
+  uint *blockno;
+  struct buf *bp;
+  
+  begin_op();
+  for(blockno = dst_sp->blocknos; blockno < &dst_sp->blocknos[NBLOCKPERPAGE]; blockno++, src_pa += BSIZE){
+    *blockno = balloc(ROOTDEV);
+    if(*blockno == 0)
+      panic("swapout");
+    bp = bread(ROOTDEV, *blockno);
+    memmove(bp->data, src_pa, BSIZE);
+    log_write(bp);
+    brelse(bp);
+  }
+  end_op();
+}
+
+// Swap in a page into dst_pa from disk using src_sp.
+// src_sp should normally be updated with metadata
+// for retriving the page by a call to swapout().
+void
+swapin(char *dst_pa, struct swap *src_sp)
+{
+  uint *blockno;
+  struct buf *bp;
+  
+  if(!dst_pa)
+    panic("swapin");
+  for(blockno = src_sp->blocknos; blockno < &src_sp->blocknos[NBLOCKPERPAGE]; blockno++, dst_pa += BSIZE){
+    bp = bread(ROOTDEV, *blockno);
+    memmove(dst_pa, bp->data, BSIZE);
+    brelse(bp);
+  }
+}
diff --git a/kernel/trap.c b/kernel/trap.c
index 512c850..1dcd93d 100644
--- a/kernel/trap.c
+++ b/kernel/trap.c
@@ -50,7 +50,29 @@ usertrap(void)
   // save user program counter.
   p->trapframe->epc = r_sepc();
   
-  if(r_scause() == 8){
+  //----------------------------------------------------
+  pte_t *pte;
+  uint64 va;
+  // read or write page-fault
+  if(r_scause() == 13 || r_scause() == 15)
+  {
+    va = PGROUNDDOWN(r_stval());
+    // if vitual address > process size or virtual address == 0
+    if(va > p->sz || va == 0)
+      setkilled(p);
+    else
+    {
+      // searching virtual address or check supervised bit on or not
+      if((pte = walk(p->pagetable, va, 0)) == 0 || (*pte & PTE_S) == 0)
+      panic("usertrap");
+      
+      //swap_in_alloc(pte) is our physical address
+      LivePageAdd(p->pagetable, swap_in_alloc(pte), va);
+    }
+  }
+  //------------------------------------------------------
+  else if(r_scause() == 8)
+  {
     // system call
 
     if(killed(p))
@@ -66,6 +88,7 @@ usertrap(void)
 
     syscall();
   } else if((which_dev = devintr()) != 0){
+    printf("inside usertrap\n");
     // ok
   } else {
     printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
@@ -145,6 +168,7 @@ kerneltrap()
     panic("kerneltrap: interrupts enabled");
 
   if((which_dev = devintr()) == 0){
+    printf("inside kerneltrap\n");
     printf("scause %p\n", scause);
     printf("sepc=%p stval=%p\n", r_sepc(), r_stval());
     panic("kerneltrap");
@@ -189,6 +213,7 @@ devintr()
     if(irq == UART0_IRQ){
       uartintr();
     } else if(irq == VIRTIO0_IRQ){
+      // printf("here\n");
       virtio_disk_intr();
     } else if(irq){
       printf("unexpected interrupt irq=%d\n", irq);
diff --git a/kernel/vm.c b/kernel/vm.c
index 9f69783..a1d3e46 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -15,6 +15,132 @@ extern char etext[];  // kernel.ld sets this to end of kernel code.
 
 extern char trampoline[]; // trampoline.S
 
+//---------------------------------------------------------
+
+#define MAXPHYPAGES 12
+uint queue_first = 0;
+
+struct pageList {
+  pagetable_t pt;
+  uint64 pa, va;
+  int in_use;
+} pageArray[MAXPHYPAGES];
+
+void updatePage(uint i,pagetable_t pagetable, uint64 pa, uint64 va)
+{
+  pageArray[i].pt = pagetable;
+  pageArray[i].pa = pa;
+  pageArray[i].va = va;
+  pageArray[i].in_use = 1;
+}
+
+void updateQueueHead(uint num)
+{
+  if(num == MAXPHYPAGES - 1)
+    queue_first = 0;
+
+}
+
+void
+LivePageAdd(pagetable_t pagetable, uint64 pa, uint64 va)
+{
+  // printf("add initial head: %d\n", queue_first);
+  // printf("inside LivePageAdd\n");
+  if(pageArray[queue_first].in_use == 1)
+  {
+    struct swap *s;
+    pte_t* pte;
+    uint64 flags;
+    //-----------------------------------------------
+    //swap
+    struct swap *sw = swapalloc();
+    swapout(sw, (char*)pa);
+    kfree((void*)pa);
+    //-----------------------------------------------
+    s = sw;
+    /* update the corresponding pte for this newly swapped out page */
+    if((pte = walk(pageArray[queue_first].pt, pageArray[queue_first].va, 0)) == 0 || (*pte & PTE_V) == 0)
+      panic("LivePageAdd: pte should exist or not present");
+
+    flags = PTE_FLAGS(*pte);
+    *pte = flags ;
+    *pte = *pte | ((flags & PTE_R) << PTE_SR_POS) ;
+    *pte = *pte | ((flags & PTE_W) << PTE_SW_POS);
+    *pte = *pte | ((uint64)s << PTE_PA_POS);
+    *pte = *pte & ~(PTE_R);
+    *pte = *pte & ~(PTE_W);
+    *pte = *pte & ~(PTE_V);
+    *pte = *pte | (PTE_S);
+  }
+  //update if
+  updatePage(queue_first,pagetable,pa,va);
+  updateQueueHead(queue_first);
+
+  printf("add final head: %d\n", queue_first);
+}
+
+void
+remove_from_live(pagetable_t pagetable, uint64 va)
+{
+  printf("remove initial head: %d\n", queue_first);
+  printf("inside remove_from_live\n");
+  int i = 0;
+  while(i < MAXPHYPAGES)
+  {
+    // finding out which virtual address matched with remove from live page
+    if(pagetable == pageArray[i].pt && va == pageArray[i].va)
+    {
+      printf("found\n");
+      break;
+    }
+    i++;
+  }
+  printf("index: %d\n", i);
+  while(i<MAXPHYPAGES)
+  {
+    if(pageArray[i+1].in_use == 1)
+      updatePage(i,pageArray[i+1].pt,pageArray[i+1].pa,pageArray[i+1].va);
+
+    else
+    {
+      pageArray[i].in_use = 0;
+      queue_first = i;
+      break;
+    }
+    i++;
+  }
+  updateQueueHead(i);
+  printf("remove final head: %d\n", queue_first);
+}
+
+uint64
+swap_in_alloc(pte_t* pte)
+{
+  struct swap *s;
+  uint64 pa;
+  uint flags;
+
+//------------------------------------------------
+//swapIn
+  s = (struct swap*) ((*pte) >> PTE_PA_POS);
+  char* mem = kalloc();
+  swapin(mem, s);
+  swapfree(s);
+  pa =(uint64)mem;
+//------------------------------------------------
+  
+  flags = PTE_FLAGS(*pte);
+  flags = flags | ((flags & PTE_SR) << PTE_R_POS);
+  flags = flags | ((flags & PTE_SW) << PTE_W_POS);
+  flags = flags | PTE_V;
+  flags = flags & ~(PTE_S);
+  *pte  = flags | (pa << PTE_SR_POS);
+
+  return pa;
+}
+
+//----------------------------------------------------------------
+
 // Make a direct-map page table for the kernel.
 pagetable_t
 kvmmake(void)
@@ -56,6 +182,13 @@ kvminit(void)
   kernel_pagetable = kvmmake();
 }
 
+void
+livepageinit(void)
+{
+  for(int i = 0; i < MAXPHYPAGES; i++)
+    pageArray[i].in_use = 0;
+}
+
 // Switch h/w page table register to the kernel's page table,
 // and enable paging.
 void
@@ -170,22 +303,38 @@ mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
 void
 uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
 {
-  uint64 a;
+  struct swap *s;
+  uint64 a, pa;
   pte_t *pte;
+  uint flags;
 
   if((va % PGSIZE) != 0)
     panic("uvmunmap: not aligned");
 
-  for(a = va; a < va + npages*PGSIZE; a += PGSIZE){
+  for(a = va; a < va + npages*PGSIZE; a += PGSIZE)
+  {
     if((pte = walk(pagetable, a, 0)) == 0)
       panic("uvmunmap: walk");
-    if((*pte & PTE_V) == 0)
+    if((*pte & PTE_V) == 0 && (*pte & PTE_S) == 0)
       panic("uvmunmap: not mapped");
-    if(PTE_FLAGS(*pte) == PTE_V)
+    if((flags = PTE_FLAGS(*pte)) == PTE_V)
       panic("uvmunmap: not a leaf");
-    if(do_free){
-      uint64 pa = PTE2PA(*pte);
-      kfree((void*)pa);
+    if(do_free)
+    {
+      if((flags & PTE_U) && !(flags & PTE_X) && !(flags & PTE_G))
+      {
+        if(flags & PTE_S)
+        {
+          s = (struct swap*) ((*pte) >> PTE_PA_POS);
+          swapfree(s);
+        }
+        else
+        {
+          remove_from_live(pagetable, a);
+          pa = PTE2PA(*pte);
+          kfree((void*)pa);
+        }
+      }
     }
     *pte = 0;
   }
@@ -225,6 +374,7 @@ uvmfirst(pagetable_t pagetable, uchar *src, uint sz)
 uint64
 uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm)
 {
+  printf("inside uvmalloc\n");
   char *mem;
   uint64 a;
 
@@ -244,6 +394,11 @@ uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm)
       uvmdealloc(pagetable, a, oldsz);
       return 0;
     }
+
+    // va: a
+    // pa: mem
+    if((xperm & PTE_U) && !(xperm & PTE_X) && !(xperm & PTE_G))
+      LivePageAdd(pagetable, (uint64)mem, a);
   }
   return newsz;
 }
@@ -305,18 +460,32 @@ uvmfree(pagetable_t pagetable, uint64 sz)
 int
 uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
 {
+  printf("inside uvmcopy\n");
   pte_t *pte;
   uint64 pa, i;
   uint flags;
   char *mem;
+  // struct swap *s;
 
-  for(i = 0; i < sz; i += PGSIZE){
+  for(i = 0; i < sz; i += PGSIZE)
+  {
     if((pte = walk(old, i, 0)) == 0)
       panic("uvmcopy: pte should exist");
-    if((*pte & PTE_V) == 0)
+    if((*pte & PTE_V) == 0 && (*pte & PTE_S) == 0) // updated condition
       panic("uvmcopy: page not present");
-    pa = PTE2PA(*pte);
+
+    /* my code starts */
+    if((*pte) & PTE_S) 
+    {
+      pa = swap_in_alloc(pte);
+      if( ((*pte) & PTE_U) && !((*pte) & PTE_X) && !((*pte) & PTE_G) )
+        LivePageAdd(old, pa, i);
+    }
+    else
+      pa = PTE2PA(*pte);
     flags = PTE_FLAGS(*pte);
+    /* my code ends */
+
     if((mem = kalloc()) == 0)
       goto err;
     memmove(mem, (char*)pa, PGSIZE);
@@ -324,6 +493,9 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
       kfree(mem);
       goto err;
     }
+
+    if((flags & PTE_U) && !(flags & PTE_X) && !(flags & PTE_G))
+      LivePageAdd(new, (uint64)mem, i);
   }
   return 0;
 
diff --git a/page.patch b/page.patch
new file mode 100644
index 0000000..e69de29
diff --git a/user/pagetest.c b/user/pagetest.c
new file mode 100644
index 0000000..4f4776e
--- /dev/null
+++ b/user/pagetest.c
@@ -0,0 +1,17 @@
+#include "kernel/types.h"
+#include "kernel/riscv.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int main(int argc, char *argv[]) {
+    char *mem[15];
+    for (int i = 0; i < 15; ++i) {
+        mem[i] = sbrk(PGSIZE);
+        mem[i][0] = i;
+    }
+    for (int i = 0; i < 15; ++i)
+        printf("%d\n", mem[i][0]);
+    for (int i = 0; i < 15; ++i)
+        free((void *) mem);
+    return 0;
+}
\ No newline at end of file
